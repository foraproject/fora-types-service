(function() {
    "use strict";

    var _;

    var utils = require('fora-data-utils');

    var typeCache = {};


    var TypesService = function(params) {
        params = params || {};
        this.modelServices = params.modelServices;
    };


    TypesService.prototype.completeTypeDefinition = function(def, ctor) {
        def.ctor = ctor;
        if (!def.schema) {
            def.schema = {};
        }
        if (!def.schema.properties) {
            def.schema.properties = {};
        }
        if (!def.schema.required) {
            def.schema.required = [];
        }
        if (def.autoGenerated) {
            for (var k in def.autoGenerated) {
                def.schema.properties[k] = {
                    type: 'integer'
                };
                def.schema.required.push(k);
            }
        }
        return def;
    };



    TypesService.prototype.completeVirtualTypeDefinition = function*(virtualTypeDef, ctor) {
        var baseTypeDef = yield* this.getTypeDefinition(ctor.typeDefinition.name);

        var def = JSON.parse(JSON.stringify(baseTypeDef));
        def.ctor = ctor;
        if (baseTypeDef.discriminator)
            def.discriminator = baseTypeDef.discriminator;

        def.name = virtualTypeDef.name;

        def.schema = def.schema || {};
        def.schema.properties = def.schema.properties || {};
        def.schema.required = def.schema.required || [];

        def.ownProperties = [];
        if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
            for (let k in virtualTypeDef.schema.properties) {
                if (!def.schema.properties[k]) {
                    def.schema.properties[k] = virtualTypeDef.schema.properties[k];
                    def.ownProperties.push(k);
                }
            }
        }

        if (virtualTypeDef.schema && virtualTypeDef.schema.required)
            def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

        return def;
    };



    TypesService.prototype.buildTypeCache = function*(ctors, virtualTypeDefinitions) {
        var self = this;

        var def, type;

        //Add the base types
        ctors.forEach(function(ctor) {
            def = self.completeTypeDefinition(ctor.typeDefinition, ctor);
            typeCache[def.name] = def;
        });

        //Add virtual types
        if (virtualTypeDefinitions && virtualTypeDefinitions.length) {
            for(let i = 0; i < virtualTypeDefinitions.length; i++) {
                let item = virtualTypeDefinitions[i];
                def = yield* self.completeVirtualTypeDefinition(item.typeDefinition, item.ctor);
                typeCache[def.name] = def;
            }
        }

        //References will resolve now.
        for (type in typeCache) {
            _ = yield* this.resolveReferencesInDef(typeCache[type]);
        }
    };



    TypesService.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
        var self = this;

        var fn = function*(prop, val) {
            var subTypeDef;
            if (val.type === 'object') {
                if (val.properties) {
                    subTypeDef = {
                        name: "<anonymous>",
                        schema: {
                            type: val.type,
                            properties: val.properties,
                            required: val.required
                        }
                    };
                    prop.typeDefinition = subTypeDef;
                    _ = yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
                }
            } else if (val.$ref) {
                prop.typeDefinition = yield* self.getTypeDefinition(val.$ref, dynamicResolutionContext);
                if (!prop.typeDefinition) {
                    throw new Error("Unable to resolve " + val.$ref);
                }
            }
        };

        for (var property in def.schema.properties) {
            var value = def.schema.properties[property];
            if (value.type === 'array') {
                _ = yield* fn(def.schema.properties[property].items, value.items);
            } else {
                _ = yield* fn(def.schema.properties[property], value);
            }
        }
    };



    TypesService.prototype.getTypeDefinitions = function() {
        return typeCache;
    };



    TypesService.prototype.getTypeDefinition = function*(name, dynamicResolutionContext) {
        if (typeCache[name])
            return typeCache[name];

        if (!dynamicResolutionContext)
            dynamicResolutionContext = {};

        return dynamicResolutionContext[name] || (yield* this.getDynamicTypeDefinition(name, dynamicResolutionContext));
    };



    TypesService.prototype.getDynamicTypeDefinition = function*(name, dynamicResolutionContext) {
        throw new Error("resolveDynamicTypeDefinition() method must be overridden in derived class");
    };



    TypesService.prototype.constructModel = function*(obj, ctor) {
        var typeDefinition = yield* this.getTypeDefinition(ctor.typeDefinition.name);
        return yield* this.updateModel(null, obj, typeDefinition);
    };



    TypesService.prototype.constructFromTypeDefinition = function*(obj, typeDefinition) {
        return yield* this.updateModel(null, obj, typeDefinition);
    };



    TypesService.prototype.updateModel = function*(target, obj, typeDefinition) {

        var effectiveTypeDef, original;

        if (typeDefinition.discriminator) {
            effectiveTypeDef = yield* typeDefinition.discriminator(obj, this);
        } else {
            effectiveTypeDef = typeDefinition;
        }

        var result = yield* _updateModel_impl.call(this, target, obj, effectiveTypeDef);

        if (effectiveTypeDef.trackChanges) {
            var clone = JSON.parse(JSON.stringify(obj));
            original = yield* _updateModel_impl.call(this, null, clone, effectiveTypeDef);
            result.getOriginalModel = function() {
                return original;
            };
        }

        /*
            If the object is a dynamic type (effectiveTypeDef !== typeDefinition),
            we can't get the type info from getTypeDefinition(). So we overwrite getTypeDefinition with
            a new method which returns effectiveTypeDef.
        */
        if (effectiveTypeDef !== typeDefinition) {
            result.getTypeDefinition = function*() {
                return effectiveTypeDef;
            };
            if (effectiveTypeDef.trackChanges) {
                original.getTypeDefinition = function*() {
                    return effectiveTypeDef;
                };
            }
        }

        if (typeDefinition.initialize) {
            _ = yield* typeDefinition.initialize(result);
        }

        return result;
    };



    var _updateModel_impl = function*(target, obj, typeDefinition) {
        var fnCtor;
        if (typeDefinition.customConstructor) {
            return target || (yield* typeDefinition.customConstructor(obj, this));
        } else {
            var result = target || {};
            _ = yield* updateModelFields.call(this, result, obj, typeDefinition);
            return target ? result : (typeDefinition.ctor ? new typeDefinition.ctor(result, this) : result);
        }
    };


    /*
        Update fields on target. Target must be an object.
    */
    var updateModelFields = function*(target, obj, typeDefinition) {

        for (var name in typeDefinition.schema.properties) {
            var arr;
            var def = typeDefinition.schema.properties[name];
            var value = obj[name];

            if (!this.modelServices.isModel || (this.modelServices.isModel && !this.modelServices.isModel(value))) {
                if (utils.isPrimitiveType(def.type)) {
                    if (value !== undefined && value !== null) {
                        if (def.type === 'array') {
                            if (def.items.typeDefinition) {
                                arr = [];
                                for (var _i = 0; _i < value.length; _i++) {
                                    var item = value[_i];
                                    arr.push(yield* this.constructFromTypeDefinition(item, def.items.typeDefinition));
                                }
                                value = arr;
                            }
                        }
                    }
                } else {
                    if (def.typeDefinition) {
                        if (value) {
                            value = yield* this.constructFromTypeDefinition(value, def.typeDefinition);
                        }
                    }
                }
            }

            target[name] = value;
        }

        if (typeDefinition.autoGenerated) {
            for (var fieldName in typeDefinition.autoGenerated) {
                target[fieldName] = obj[fieldName];
            }
        }

        if (this.modelServices) {
            var rowId = this.modelServices.getRowId(obj);
            if (rowId)
                this.modelServices.setRowId(target, rowId);
        }

    };



    var initted = false;
    TypesService.prototype.init = function*(ctors, virtualTypeDefinitions) {
        if (!initted) {
            _ = yield* this.buildTypeCache(ctors, virtualTypeDefinitions);
        } else {
            throw new Error("init() was already called");
        }
    };


    module.exports = TypesService;

})();
