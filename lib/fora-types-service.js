(function() {
    "use strict";

    var _;

    var utils = require('fora-data-utils');

    var typeCache = {};


    var TypesService = function(params) {
        params = params || {};
        this.modelServices = params.modelServices;
    };


    TypesService.prototype.completeTypeDefinition = function(def) {
        if (!def.schema) {
            def.schema = {};
        }
        if (!def.schema.properties) {
            def.schema.properties = {};
        }
        if (!def.schema.required) {
            def.schema.required = [];
        }
        if (def.autoGenerated) {
            for (var k in def.autoGenerated) {
                def.schema.properties[k] = {
                    type: 'integer'
                };
                def.schema.required.push(k);
            }
        }

        return def;
    };



    TypesService.prototype.completeVirtualTypeDefinition = function*(virtualTypeDef, baseTypeDefinition) {
        var def = JSON.parse(JSON.stringify(baseTypeDefinition));

        def.name = virtualTypeDef.name;
        def.baseTypeDefinition = baseTypeDefinition;
        def.schema = def.schema || {};
        def.schema.properties = def.schema.properties || {};
        def.schema.required = def.schema.required || [];

        def.ownProperties = [];
        if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
            for (let k in virtualTypeDef.schema.properties) {
                if (!def.schema.properties[k]) {
                    def.schema.properties[k] = virtualTypeDef.schema.properties[k];
                    def.ownProperties.push(k);
                }
            }
        }

        if (virtualTypeDef.schema && virtualTypeDef.schema.required)
            def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

        return def;
    };



    TypesService.prototype.buildTypeCache = function*(typeDefinitions, virtualTypeDefinitionsList) {
        var self = this;

        var def, type;

        //Add the base types
        typeDefinitions.forEach(function(def) {
            var fullDef = self.completeTypeDefinition(def);
            typeCache[def.name] = fullDef;
        });

        //Add virtual types
        if (virtualTypeDefinitionsList) {
            for (var i = 0; i < virtualTypeDefinitionsList.length; i++) {
                var vTypeDefs = virtualTypeDefinitionsList[i];
                for(var j = 0; j < vTypeDefs.typeDefinitions.length; j++) {
                    def = yield* self.completeVirtualTypeDefinition(vTypeDefs.typeDefinitions[j], vTypeDefs.baseTypeDefinition);
                    typeCache[def.name] = def;
                }
            }
        }

        //References will resolve now.
        for (type in typeCache) {
            _ = yield* this.resolveReferencesInDef(typeCache[type]);
        }
    };



    TypesService.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
        var self = this;

        var fn = function*(prop, val) {
            var subTypeDef;
            if (val.type === 'object') {
                if (val.properties) {
                    subTypeDef = {
                        name: "<anonymous>",
                        schema: {
                            type: val.type,
                            properties: val.properties,
                            required: val.required
                        }
                    };
                    prop.typeDefinition = subTypeDef;
                    _ = yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
                }
            } else if (val.$ref) {
                prop.typeDefinition = yield* self.getTypeDefinition(val.$ref, dynamicResolutionContext);
                if (!prop.typeDefinition) {
                    throw new Error("Unable to resolve " + val.$ref);
                }
            }
        };

        for (var property in def.schema.properties) {
            var value = def.schema.properties[property];
            if (value.type === 'array') {
                _ = yield* fn(def.schema.properties[property].items, value.items);
            } else {
                _ = yield* fn(def.schema.properties[property], value);
            }
        }
    };



    TypesService.prototype.getTypeDefinitions = function() {
        return typeCache;
    };



    TypesService.prototype.getTypeDefinition = function*(name, dynamicResolutionContext) {
        if (typeCache[name])
            return typeCache[name];

        if (!dynamicResolutionContext)
            dynamicResolutionContext = {};

        return dynamicResolutionContext[name] || (yield* this.getDynamicTypeDefinition(name, dynamicResolutionContext));
    };



    TypesService.prototype.getDynamicTypeDefinition = function*(name, dynamicResolutionContext) {
        throw new Error("resolveDynamicTypeDefinition() method must be overridden in derived class");
    };



    TypesService.prototype.constructModel = function*(obj, typeDefinition, skipInitialize) {
        return yield* this.updateModel(null, obj, typeDefinition, skipInitialize);
    };



    TypesService.prototype.updateModel = function*(target, obj, typeDefinition, skipInitialize) {
        var effectiveTypeDef;

        if (typeDefinition.discriminator) {
            effectiveTypeDef = yield* typeDefinition.discriminator(obj, this);
        } else {
            effectiveTypeDef = typeDefinition;
        }

        var result = yield* _updateModel_impl.call(this, target, obj, effectiveTypeDef);

        if (this.modelServices.setTypeDefinition) {
            _ = yield* this.modelServices.setTypeDefinition.call(result, effectiveTypeDef);
        }

        if (typeDefinition.initialize && !skipInitialize) {
            _ = yield* typeDefinition.initialize(result, obj, effectiveTypeDef, this);
        }

        return result;
    };



    var _updateModel_impl = function*(target, obj, typeDefinition) {
        var result = target || {};
        _ = yield* updateModelFields.call(this, result, obj, typeDefinition);

        if (!target) {
            if (typeDefinition.baseTypeDefinition && typeDefinition.baseTypeDefinition.ctor)
                return typeDefinition.baseTypeDefinition.ctor(result, this);
            else if (typeDefinition.ctor)
                return typeDefinition.ctor(result, this);
        }

        return result;
    };


    /*
        Update fields on target. Target must be an object.
    */
    var updateModelFields = function*(target, obj, typeDefinition) {

        for (var name in typeDefinition.schema.properties) {
            var arr;
            var def = typeDefinition.schema.properties[name];
            var value = obj[name];

            if (!this.modelServices.isModel || (this.modelServices.isModel && !this.modelServices.isModel(value))) {
                if (utils.isPrimitiveType(def.type)) {
                    if (value !== undefined && value !== null) {
                        if (def.type === 'array') {
                            if (def.items.typeDefinition) {
                                arr = [];
                                for (var _i = 0; _i < value.length; _i++) {
                                    var item = value[_i];
                                    arr.push(yield* this.constructModel(item, def.items.typeDefinition));
                                }
                                value = arr;
                            }
                        }
                    }
                } else {
                    if (def.typeDefinition) {
                        if (value) {
                            value = yield* this.constructModel(value, def.typeDefinition);
                        }
                    }
                }
            }

            target[name] = value;
        }

        if (typeDefinition.autoGenerated) {
            for (var fieldName in typeDefinition.autoGenerated) {
                target[fieldName] = obj[fieldName];
            }
        }

        if (this.modelServices) {
            var rowId = this.modelServices.getRowId(obj);
            if (rowId)
                this.modelServices.setRowId(target, rowId);
        }

    };



    var initted = false;
    TypesService.prototype.init = function*(ctors, virtualTypeDefinitions) {
        if (!initted) {
            _ = yield* this.buildTypeCache(ctors, virtualTypeDefinitions);
        } else {
            throw new Error("init() was already called");
        }
    };


    module.exports = TypesService;

})();
